#!/usr/local/bin/bash
#
# Download or Stream anime from Gogoanime in terminal
#
#/ Usage:
#/   ./gogo-cli.sh
#/ Options:
#/	 -p						 define your fabourite player,
#/							 By default it is mpv
#/	 -H						 history Play where you left off.
#/   -d                      download rather stream
#/   -r <resolution>         optional, specify resolution to download: "1080", "720"...
#/                           by default, the highest resolution is selected
#/   -t <num>                optional, specify a positive integer as num of threads to download.
#/							 By default it is set to 8 don't use more than 16!
#/   -h | --help             display this help message

prog="gogo-cli"
logfile="${XDG_CACHE_HOME:-$HOME/.cache}/gogo-hsts"

c_red="\033[1;31m"
c_green="\033[1;32m"
c_yellow="\033[1;33m"
c_blue="\033[1;34m"
c_magenta="\033[1;35m"
c_cyan="\033[1;36m"
c_reset="\033[0m"


help_text () {
	while IFS= read line; do
		printf "%s\n" "$line"
	done <<-EOF
		USAGE: $prog <query>
		-h		show this help text
		-p		define player, default $temp
		-H		continue where you left off
		-d		download episode(episode will be download in pwd)
		-r		define resolution -r<h|n|l> high, low or normal. if res not found will fall back to normal
		-t		threads by default 8, don't use more than 16
	EOF
}


############
#  Options #
############
die () {
	printf "$c_red%s$c_reset\n" "$*" >&2
	exit 1
}

err () {
	printf "$c_red%s$c_reset\n" "$*" >&2
}

prog_not_found(){
	printf "$c_red%s$c_reset\n" "Program $1 not found. Please install it first"
	exit 1
}
# option parsing
_CURL="$(command -v curl)" || prog_not_found "curl"
_HLS="$(command -v hls)" || prog_not_found "hls"
_SED="$(command -v sed)" || prog_not_found "sed"
_GREP="$(command -v grep)" || prog_not_found "grep"
_HOST="https://gogoanime.wiki/"
_REFERER_URL="http://streamani.io/"
_PLAYER="$(command -v iina)" || prog_not_found "$temp"
_RESOLUTION=h
is_download=0
scrape=query
temp=`echo "$_PLAYER" | sed 's/.*\///'`
while getopts 'hdHp:r:t:' OPT; do
	case $OPT in
		h)
			help_text
			exit 0
			;;
		d)
			is_download=1
			;;
		t)
			_THREAD="$OPTARG"
			if [[ ! "$_THREAD" =~ ^[0-9]+$ || "$_THREAD" -eq 0 ]]; then
				printf "$c_magenta%s$c_reset\n" "-t <num>: Number must be a positive integer"
				exit
			fi
			;;
		r)
			_RESOLUTION="$OPTARG"
			if [[ ! "$_RESOLUTION" = "h" &&  ! "$_RESOLUTION" = "360" && ! "$_RESOLUTION" = "480" && ! "$_RESOLUTION" = "720" && ! "$_RESOLUTION" = "1080" && ! "$_RESOLUTION" = "l" ]]; then
				printf "$c_magenta%s$c_reset\n" "-r <h|l|360|480|720|1080>: Resolution must be hi, low, or pixel"
				exit
			fi
			;;
		p)
			_PLAYER="$OPTARG"
			;;
		H)
			scrape=history
			;;
		\?)
			printf "$c_yellow%s$c_reset\n" "Close and try again or search anime"
			;;

		esac
	done
	shift $((OPTIND - 1))
	###############
	# End Options #
	###############

	search_anime () {
		# get anime name along with its id
		search=$(printf '%s' "$1" | tr ' ' '-' )
		titlepattern='<a href="/category/'

		curl -s "$_HOST/search.html" \
			-G \
			-d "keyword=$search" |
			sed -n -E '
					s_^[[:space:]]*<a href="/category/([^"]*)" title="([^"]*)".*_\1_p
					'
				}

			search_eps () {
				# get available episodes for anime_id
				anime_id=$1

				curl -s "$_HOST/category/$anime_id" |
					sed -n -E '
									/^[[:space:]]*<a href="#" class="active" ep_start/{
									s/.* '\''([0-9]*)'\'' ep_end = '\''([0-9]*)'\''.*/\2/p
									q
								}
							'
						}


					get_video_id() {
						# get the download page url
						anime_id=$1
						ep_no=$2
						$_CURL -s "$_HOST$anime_id-episode-$ep_no" |
							sed -n -E '
													/^[[:space:]]*<a href="#" rel="100"/{
													s/.*data-video="([^"]*)".*/https:\1/p
													q
												}'
										}

									get_video_res () {
										video_id="$1"
										video_res="$2"
										video_file=$(curl -s --referer "$video_id" "$video_res")
										available_qualities=$(printf '%s' "$video_file" | sed -n -E 's/.*NAME="([^p]*)p"/\1/p')
										case $_RESOLUTION in
											h)
												printf '%s' "$available_qualities" | tail -n 1
												;;

											l)
												printf '%s' "$available_qualities" | head -n 1
												;;

											*)
												is_quality_avail=$(printf '%s' "$available_qualities" | grep "$_RESOLUTION")
												video_quality="$_RESOLUTION"
												if [ -z "$is_quality_avail" ]; then
													printf "$c_red%s$c_reset\n" "Current video quality is not available (defaulting to highest quality)" >&2
													resolution=best
													video_quality=$(printf '%s' "$available_qualities" | tail -n 1)
												fi
												printf '%s' "$video_quality"
												;;
										esac
									}
								get_video_url (){
									#$1 is video id
									video_url=$(curl -s "$1" |
										sed -n -E '
																			/^[[:space:]]*sources:/{
																			s/.*(https[^'\'']*).*/\1/p
																			q
																		}
																	')

																	video_quality=$(get_video_res "$1" "$video_url")

	# Replace the video with highest quality video
	printf '%s' "$video_url" | sed -n -E "s/(.*)\.m3u8/\1.$video_quality.m3u8/p"
}

get_download_id() {
	# get the download page id
	anime_id=$1
	ep_no=$2
	URL="$_HOST$anime_id-episode-$ep_no"
	RESULT=$(python -c 'from gogo import webscrap; import sys; webscrap.curl(sys.argv[1])' "$URL")
	printf '%s' "$RESULT" | grep "&typesub=Gogo" | sed -n 's/.*?id=//; s/&type.*//p'
}

get_download_url(){
	#$1 is download id
	URL="https://gogoplay1.com/download?id=$1"
	RESULT=$(python -c 'from gogo import webscrap; import sys; webscrap.curl(sys.argv[1])' "$URL")
	if [[ $_RESOLUTION == 'h' ]]; then
		printf '%s' "$RESULT" | grep "gogo-cdn.com" | sed 's/href="//; s/" download.*//' | tail -n 1
	elif [[ $_RESOLUTION == 'l' ]]; then
		printf '%s' "$RESULT" | grep "gogo-cdn.com" | sed 's/href="//; s/" download.*//' | head -n 1
	elif [[ "$RESULT" == *"$_RESOLUTION"* ]]; then
		printf '%s' "$RESULT" | grep -B 1 "${_RESOLUTION}P" | head -n 1 | sed 's/" download.*//'
	else
		printf '%s' "$RESULT" | grep "gogo-cdn.com" | sed 's/href="//; s/" download.*//' | tail -n 1
	fi
}


# get query
get_search_query () {
	if [ -z "$*" ]; then
		printf "Search Anime: "
		read -r query
	else
		query=$*
	fi
}

# create history file
[ -f "$logfile" ] || : > "$logfile"

#####################
## Anime selection ##
#####################

anime_selection () {
	search_results=$*
	menu_format_string='[%d] %s\n'
	menu_format_string_c1="$c_blue[$c_cyan%d$c_blue] $c_reset%s\n"
	menu_format_string_c2="$c_blue[$c_cyan%d$c_blue] $c_yellow%s$c_reset\n"

	count=1
	while read anime_id; do
		# alternating colors for menu
		[ $((count % 2)) -eq 0 ] &&
			menu_format_string=$menu_format_string_c1 ||
			menu_format_string=$menu_format_string_c2

		printf "$menu_format_string" "$count" "$anime_id"
		count=$((count+1))
	done <<-EOF
	$search_results
	EOF

	# User input
	printf "$c_blue%s$c_green" "Enter number: "
	read choice
	printf "$c_reset"

	# Check if input is a number
	[ "$choice" -eq "$choice" ] 2>/dev/null || die "Invalid number entered"

	# Select respective anime_id
	count=1
	while read anime_id; do
		if [ $count -eq $choice ]; then
			selection_id=$anime_id
			break
		fi
		count=$((count+1))
	done <<-EOF
	$search_results
	EOF

	[ -z "$selection_id" ] && die "Invalid number entered"

	read last_ep_number <<-EOF
	$(search_eps "$selection_id")
	EOF
}

##################
## Ep selection ##
##################

episode_selection () {
	[ $is_download -eq 1 ] &&
		printf "Range of episodes can be specified: start_number end_number\n"

	printf "${c_blue}Choose episode $c_cyan[1-%d]$c_reset:$c_green " $last_ep_number
	read ep_choice_start ep_choice_end
	printf "$c_reset"

}

open_episode () {
	anime_id=$1
	episode=$2

	# Cool effect way of clearing screen
	printf '\x1B[2J\x1B[1;1H'
	if [ $episode -lt 1 ] || [ $episode -gt $last_ep_number ]; then
		err "Episode out of range"
		printf "${c_blue}Choose episode $c_cyan[1-%d]$c_reset:$c_green " $last_ep_number
		read episode
		printf "$c_reset"
	fi

	printf "Getting data for episode %d\n" $episode

	video_id=$(get_video_id "$anime_id" "$episode")
	video_url=$(get_video_url "$video_id")

	if [ $is_download -eq 0 ]; then
		# write anime and episode number
		sed -E "
		s/^${selection_id}\t[0-9]+/${selection_id}\t$((episode+1))/
		" "$logfile" > "${logfile}.new" && mv "${logfile}.new" "$logfile"

		$_PLAYER --http-header-fields="Referer:$video_id" $video_url
	else
		printf "Downloading episode $episode ...\n"
		download_id=$(get_download_id "$anime_id" "$episode")
		download_url=$(get_download_url "$download_id")
		# add 0 padding to the episode name
		episode=$(printf "%03d" $episode)
		{
			aria2c -x $_THREAD -s $_THREAD -k 5M --referer=$video_id $download_url
			#$_HLS -u "$video_url" -H Referer: "$video_res" -n $_THREAD -o "${anime_id}-${episode}.mp4"
		}
	fi
}

########
# main #
########

case $scrape in
	query)
		get_search_query "$*"
		search_results=$(search_anime "$query")
		[ -z "$search_results" ] && die "No search results found"
		anime_selection "$search_results"
		episode_selection
		;;
	history)
		search_results=$(sed -n -E 's/\t[0-9]*//p' "$logfile")
		[ -z "$search_results" ] && die "History is empty"
		anime_selection "$search_results"
		ep_choice_start=$(sed -n -E "s/${selection_id}\t//p" "$logfile")
		;;
esac


check_input() { # checking input
	[ "$ep_choice_start" -eq "$ep_choice_start" ] 2>/dev/null || die "Invalid number entered"
	episodes=$ep_choice_start

	if [ -n "$ep_choice_end" ]; then
		[ "$ep_choice_end" -eq "$ep_choice_end" ] 2>/dev/null || die "Invalid number entered"
		# create list of episodes to download/watch
		episodes=$(seq $ep_choice_start $ep_choice_end)
	fi
}

# add anime to history file
append_history() {
	grep -q -w "${selection_id}" "$logfile" ||
		printf "%s\t%d\n" "$selection_id" $((episode+1)) >> "$logfile"
	}
open_selection() {
	for ep in $episodes
	do
		open_episode "$selection_id" "$ep"
	done
	episode=${ep_choice_end:-$ep_choice_start}
}

check_input
append_history
open_selection

while :; do
	printf "\n${c_green}Currently playing %s episode ${c_cyan}%d/%d\n" "$selection_id" $episode $last_ep_number
	if [ "$episode" -ne "$last_ep_number" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "n" "next episode"
	fi
	if [ "$episode" -ne "1" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "p" "previous episode"
	fi
	if [ "$last_ep_number" -ne "1" ]; then
		printf "$c_blue[${c_cyan}%s$c_blue] $c_yellow%s$c_reset\n" "s" "select episode"
	fi
	printf "$c_blue[${c_cyan}%s$c_blue] $c_magenta%s$c_reset\n" "r" "replay current episode"
	printf "$c_blue[${c_cyan}%s$c_blue] $c_cyan%s$c_reset\n" "a" "search for another anime"
	printf "$c_blue[${c_cyan}%s$c_blue] $c_red%s$c_reset\n" "q" "exit"
	printf "${c_blue}Enter choice:${c_green} "
	read choice
	printf "$c_reset"
	case $choice in
		n)
			episode=$((episode + 1))
			;;
		p)
			episode=$((episode - 1))
			;;

		s)	printf "${c_blue}Choose episode $c_cyan[1-%d]$c_reset:$c_green " $last_ep_number
			read episode
			printf "$c_reset"
			[ "$episode" -eq "$episode" ] 2>/dev/null || die "Invalid number entered"
			;;

		r)
			episode=$((episode))
			;;
		a)
			tput reset
			get_search_query ""
			search_results=$(search_anime "$query")
			[ -z "$search_results" ] && die "No search results found"
			anime_selection "$search_results"
			episode_selection
			check_input
			append_history
			open_selection
			continue
			;;

		q)
			break;;

		*)
			die "invalid choice"
			;;
	esac

	open_episode "$selection_id" "$episode"
done
